import { Request, Response } from 'express';
import CertificateApplication, { ICertificateApplication } from '../models/CertificateApplication';
import path from 'path';
import fs from 'fs';
import PDFDocument from 'pdfkit';
import mongoose from 'mongoose';

// In-memory storage for demo purposes when MongoDB is not available
const inMemoryApplications = new Map<string, any>();

// In-memory storage for demo purposes
// In production, use a proper file storage solution
const UPLOAD_DIR = path.join(__dirname, '../../uploads');

// Create directories if they don't exist
if (!fs.existsSync(UPLOAD_DIR)) {
  fs.mkdirSync(UPLOAD_DIR, { recursive: true });
}

// Generate a PDF certificate with watermark, seal, and signature
const generateCertificatePDF = async (application: any): Promise<string> => {
  return new Promise((resolve, reject) => {
    try {
      const fileName = `certificate_${application._id}.pdf`;
      const filePath = path.join(UPLOAD_DIR, fileName);
      
      // Create a document
      const doc = new PDFDocument({
        size: 'A4',
        margin: 50
      });
      
      // Pipe its output to a file
      doc.pipe(fs.createWriteStream(filePath));
      
      // Add watermark
      doc.save();
      doc.fontSize(20);
      doc.fillColor('#d1d5db'); // Light gray for watermark
      doc.text('Digital e-Gram Panchayat - Official', 100, 300, {
        width: 400,
        align: 'center',
        oblique: true
      });
      doc.restore();
      
      // Add header with government seal
      doc.save();
      doc.fontSize(24);
      doc.fillColor('#000000');
      doc.text('CERTIFICATE', 0, 50, { width: doc.page.width, align: 'center' });
      
      doc.fontSize(18);
      doc.text(`OF ${application.certificateType.toUpperCase()}`, 0, 90, { width: doc.page.width, align: 'center' });
      
      // Draw a simple seal (circle with text)
      const centerX = doc.page.width - 60;
      const centerY = 60;
      doc.circle(centerX, centerY, 25).stroke('#dc2626'); // Red circle for seal
      doc.fontSize(8);
      doc.text('GOVT', centerX - 15, centerY - 5, { width: 30, align: 'center' });
      doc.text('SEAL', centerX - 15, centerY + 5, { width: 30, align: 'center' });
      doc.restore();
      
      // Add content to the PDF
      doc.fontSize(12);
      doc.fillColor('#000000');
      doc.text('This is to certify that', 0, 150, { width: doc.page.width, align: 'center' });
      doc.moveDown();
      
      doc.fontSize(18);
      doc.text(application.applicantName, 0, 180, { width: doc.page.width, align: 'center' });
      doc.moveDown();
      
      doc.fontSize(12);
      doc.text(`was involved in a ${application.certificateType.toLowerCase()} event`, 0, 210, { width: doc.page.width, align: 'center' });
      doc.moveDown();
      
      doc.fontSize(12);
      doc.text(`on ${new Date(application.date).toDateString()}`, 0, 240, { width: doc.page.width, align: 'center' });
      doc.moveDown();
      
      doc.fontSize(12);
      doc.text(`at ${application.place}`, 0, 270, { width: doc.page.width, align: 'center' });
      doc.moveDown(3);
      
      doc.fontSize(10);
      doc.text(`Application ID: ${application._id}`, 0, 320, { width: doc.page.width, align: 'center' });
      doc.moveDown();
      
      doc.fontSize(10);
      doc.text(`Status: ${application.status}`, 0, 340, { width: doc.page.width, align: 'center' });
      doc.moveDown(3);
      
      // Add signature area
      doc.fontSize(10);
      doc.text('Generated by Digital e-Gram Panchayat', 50, doc.page.height - 100);
      
      // Draw signature line
      doc.moveTo(350, doc.page.height - 80)
         .lineTo(doc.page.width - 50, doc.page.height - 80)
         .stroke();
      
      doc.text('Authorized Officer Signature', 350, doc.page.height - 70);
      
      // Add official stamp text
      doc.fontSize(8);
      doc.text('Official Stamp', 0, doc.page.height - 50, { width: doc.page.width, align: 'center' });
      
      // Finalize PDF file
      doc.end();
      
      // Resolve with the file name when the document is finished
      doc.on('end', () => {
        resolve(fileName);
      });
      
      // Handle errors
      doc.on('error', (err) => {
        reject(err);
      });
    } catch (error) {
      reject(error);
    }
  });
};

// Helper function to generate a mock ID
const generateMockId = () => {
  return 'CRT-' + Date.now().toString(36).toUpperCase() + Math.random().toString(36).substr(2, 5).toUpperCase();
};

export const applyForCertificate = async (req: Request, res: Response) => {
  try {
    const { applicantName, certificateType, date, place, supportingFiles } = req.body;
    
    // Validate required fields
    if (!applicantName || !certificateType || !date || !place) {
      return res.status(400).json({ 
        success: false, 
        message: 'All required fields must be provided' 
      });
    }
    
    // Create new certificate application
    const newApplication = {
      _id: generateMockId(),
      applicantName,
      certificateType,
      date: new Date(date),
      place,
      supportingFiles: supportingFiles || [],
      status: 'Submitted',
      createdAt: new Date()
    };
    
    // Save to in-memory storage
    inMemoryApplications.set(newApplication._id, newApplication);
    
    // Update status to Ready
    newApplication.status = 'Ready';
    
    // Generate certificate file
    const certificateFile = await generateCertificatePDF(newApplication);
    
    res.status(201).json({
      success: true,
      message: 'Certificate application submitted successfully',
      applicationId: newApplication._id,
      status: newApplication.status,
      downloadUrl: `/api/certificates/${newApplication._id}/download`
    });
  } catch (error) {
    console.error('Error applying for certificate:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Internal server error' 
    });
  }
};

export const getCertificatePreview = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    
    // Try to get from MongoDB first, then from in-memory storage
    let application = null;
    
    try {
      application = await CertificateApplication.findById(id);
    } catch (dbError) {
      // If MongoDB is not available, check in-memory storage
      application = inMemoryApplications.get(id);
    }
    
    if (!application) {
      return res.status(404).json({ 
        success: false, 
        message: 'Certificate application not found' 
      });
    }
    
    res.status(200).json(application);
  } catch (error) {
    console.error('Error fetching certificate preview:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Internal server error' 
    });
  }
};

export const updateCertificate = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const updateData = req.body;
    
    // Try to get from MongoDB first, then from in-memory storage
    let application = null;
    
    try {
      application = await CertificateApplication.findById(id);
      if (application) {
        // Update the application with new data
        Object.assign(application, updateData);
        // Save the updated application
        const updatedApplication = await application.save();
        application = updatedApplication;
      }
    } catch (dbError) {
      // If MongoDB is not available, check in-memory storage
      application = inMemoryApplications.get(id);
      if (application) {
        // Update the in-memory application
        Object.assign(application, updateData);
        inMemoryApplications.set(id, application);
      }
    }
    
    if (!application) {
      return res.status(404).json({ 
        success: false, 
        message: 'Certificate application not found' 
      });
    }
    
    // Regenerate the certificate file with updated data
    const certificateFile = await generateCertificatePDF(application);
    
    res.status(200).json(application);
  } catch (error) {
    console.error('Error updating certificate:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Internal server error' 
    });
  }
};

export const getCertificateStatus = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    
    // Try to get from MongoDB first, then from in-memory storage
    let application = null;
    
    try {
      application = await CertificateApplication.findById(id);
    } catch (dbError) {
      // If MongoDB is not available, check in-memory storage
      application = inMemoryApplications.get(id);
    }
    
    if (!application) {
      return res.status(404).json({ 
        success: false, 
        message: 'Certificate application not found' 
      });
    }
    
    res.status(200).json({
      success: true,
      applicationId: application._id,
      status: application.status,
      certificateType: application.certificateType,
      applicantName: application.applicantName,
      date: application.date,
      place: application.place
    });
  } catch (error) {
    console.error('Error fetching certificate status:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Internal server error' 
    });
  }
};

export const downloadCertificate = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { format } = req.query; // 'pdf' or 'jpg'
    
    // Try to get from MongoDB first, then from in-memory storage
    let application = null;
    
    try {
      application = await CertificateApplication.findById(id);
    } catch (dbError) {
      // If MongoDB is not available, check in-memory storage
      application = inMemoryApplications.get(id);
    }
    
    if (!application) {
      return res.status(404).json({ 
        success: false, 
        message: 'Certificate application not found' 
      });
    }
    
    if (application.status !== 'Ready') {
      return res.status(400).json({ 
        success: false, 
        message: 'Certificate is not ready for download' 
      });
    }
    
    // Create proper filename based on certificate type
    const fileNameBase = `${application.certificateType.toLowerCase()}-certificate`;
    
    // For PDF format
    if (format === 'pdf' || !format) {
      const fileName = `certificate_${id}.pdf`;
      const filePath = path.join(UPLOAD_DIR, fileName);
      
      if (!fs.existsSync(filePath)) {
        return res.status(404).json({ 
          success: false, 
          message: 'Certificate file not found' 
        });
      }
      
      // Set appropriate headers for PDF download with proper filename
      res.setHeader('Content-Disposition', `attachment; filename="${fileNameBase}.pdf"`);
      res.setHeader('Content-Type', 'application/pdf');
      
      // Send the file
      res.sendFile(filePath);
      return;
    }
    
    // For JPG format, we would need to convert PDF to JPG
    // For simplicity, we'll just send a placeholder
    res.setHeader('Content-Disposition', `attachment; filename="${fileNameBase}.jpg"`);
    res.setHeader('Content-Type', 'image/jpeg');
    
    // Send a placeholder image
    res.send(Buffer.from('iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==', 'base64'));
  } catch (error) {
    console.error('Error downloading certificate:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Internal server error' 
    });
  }
};